<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Covalue</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Covalue</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../projects.html">Projects</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Unrealistic Models for Realistic Computations</h1>
            <article>
    <section class="header">
        Posted on July  7, 2022
        
    </section>
    <section>
        <p>Papayannopoulos, [2020] <a href="http://philsci-archive.pitt.edu/19634/">“Unrealistic Models for Realistic Computations: How Idealizations Help Represent Mathematical Structures and Found Scientific Computing”</a>.</p>
<p>Scientific computing aka <a href="https://en.wikipedia.org/wiki/Computational_science">computational science</a>, i.e., the general techniques for all computational branches of empirical sciences, can be divided into symbolic and numerical methods; the paper deals with the latter. Since numerical methods work with continuous values (real/complex numbers and their generalizations), there are questions of convergence, stability, and computability of algorithms over floating point arithmetic (in particular, the problem of accumulation of round-off errors). To study these questions, we need a mathematical framework for computing over uncountable sets, the most popular of which are the <a href="https://en.wikipedia.org/wiki/Blum%E2%80%93Shub%E2%80%93Smale_machine">BSS model</a> (aka Real-RAM) and <a href="https://en.wikipedia.org/wiki/Computable_analysis">computable analysis</a> (aka Type Two Effectivity), and they are incompatible with each other. This article is devoted to a breakdown of these two approaches.</p>
<p>CA/TTE is a more fundamental and “low-level” theory, it is a form of mathematical analysis where the classical theory is preserved, but in addition computational representations of objects by infinite approximations are taken into account. This is usually done by working with some varieties of Turing machines (with an oracle or more complex representation machinery). Its origin can be traced back to the work of Borel, Banach, and Turing in the 1910s-30s, where computable subsets of R were considered (this idea was developed in the Markov school of constructivism/synthetic computability). Later approaches (“Hagen school”) moved to considering all of R (a key idea of TTE). In this model, computable functions must be continuous - as a consequence, we lose the possibility to fully use “point” comparison and rounding functions (see <a href="https://twitter.com/andrejbauer/status/1400172747930718209">this tweet</a>).</p>
<p>BSS is a model of computation with an idealized RAM machine capable of storing arbitrary numbers (including exact values of real numbers) in memory and instantly performing arithmetic operations on them. There are no problems with discontinuous functions, but working with algebraic and transcendental functions (which CA has no problem with), starting with trivial square roots, becomes more complicated.</p>
<p>So which framework is better? BSS is less realistic and less good at handling rounding errors and <a href="https://en.wikipedia.org/wiki/Condition_number">ill-conditioned</a> functions, but it is still quite popular - it models stable algorithms (i.e., it does not introduce its own errors) and allows you to work with their complexity estimates. Also, BSS is closer to floating arithmetic algorithms in that it has a fixed cost of operations (unlike CA, where the cost depends on the input). CA, on the other hand, is suitable for deeper computability issues (including, for example, quantum computability) and for dealing with “ill-behaved” functions, but poses more problems for cost analysis and for dealing with well-studied numerical algorithms.</p>
<p>The article ends with an analogy to physical models that make work easier by unrealistic simplifications, e.g. floating numbers can be seen as analogous to experimental values - i.e., classical and computational mathematics live in different realities.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
