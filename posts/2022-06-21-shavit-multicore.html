<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Covalue</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Covalue</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../projects.html">Projects</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Data structures in the multicore age</h1>
            <article>
    <section class="header">
        Posted on June 21, 2022
        
    </section>
    <section>
        <p>Shavit, [2011] <a href="http://people.csail.mit.edu/shanir/publications/p76-shavit.pdf">“Data structures in the multicore age”</a> is a relatively well-known popular science article from a decade ago by one of the concurrency coryphaei on the future of multithreaded (library) programming.</p>
<p>It starts with a motivation of <a href="https://en.wikipedia.org/wiki/Amdahl's_law">Amdahl’s Law</a> about the bottleneck of parallel computing. Then it mentions that correctness in the multithreaded setting breaks down into two aspects: safety (relative to the <a href="https://en.wikipedia.org/wiki/Consistency_model">consistency model</a>, e.g. linearizability) and liveness (progress conditions - lock-free/wait-free and more exotic). The tools for dealing with complexity are also changing - the stalls model is added, we need to keep a close eye on <a href="https://en.wikipedia.org/wiki/Bus_contention">contention</a>. A prediction is made that the development of algorithms and data structures will go down the way of relaxing guarantees (it seems that after 10+ years these are still pretty niche things).</p>
<p>Most of the article is spent on an example of the process of “weakening” a multi-threaded stack in Java, going through several phases:</p>
<ol type="1">
<li>Stack under spinlock - linearizable, non-parallel (deadlock-free), bus congestion due to uncontrolled spins (usually solved by backoff circuits).</li>
<li>Lock-free stack - specializes the lock to a CAS at the top of the stack.</li>
<li>Elimination backoff stack - removes the sequential bottleneck, obtaining the so-called “dual” structure - i.e. allowing tracks to leave “antidata” (requests) and transfer elements directly without writing to the stack, still linearizable.</li>
<li>Elimination tree - duality does not work well in the case of packets of identical operations, so we can weaken the consistency to the quiescent model (illusion of linearity only during periods of inactivity) by splitting the stack into several parallel ones and covering them with balancers.</li>
<li>Stack pool - ultimately the problem is the sequential logic of the stack itself, so further performance gains can be achieved by removing the balancing machinery and turning the stack into a carefully architected, weakly-ordered structure, which the author believes should be sufficient for most applications.</li>
</ol>
<p>Other structures should be similarly relaxed, e.g. by switching to hashing instead of exact queries. This seems to have partly come true with the popularization of probabilistic structures like the <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
