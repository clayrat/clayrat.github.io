<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Covalue</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Covalue</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../projects.html">Projects</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Program Analysis with Interpolants (and the history of model checking)</h1>
            <article>
    <section class="header">
        Posted on April 22, 2025
        
    </section>
    <section>
        <p><a href="https://www.georg.weissenbacher.science/papers/dissertation.pdf">Weißenbacher, [2010] “Program Analysis with Interpolants”</a></p>
<p>This high-quality dissertation provides an overview of the state of affairs in model checking as of 2010.</p>
<p>In short, the idea of model checking can be described as follows: we want to automatically verify programs, so we approximate them with models - i.e., automata or <a href="https://en.wikipedia.org/wiki/Transition_system">transition systems</a> with a finite set of states, set a specification (usually in some variety of propositional <a href="https://en.wikipedia.org/wiki/Temporal_logic">temporal logic</a>), and then, using search algorithms and heuristics, exhaustively search through the states of the model, checking that the specification holds for all states.</p>
<p>Conceptually, this approach is described by <a href="https://en.wikipedia.org/wiki/Model_theory">model theory</a> (one of the two main branches of logic, the second being <a href="https://en.wikipedia.org/wiki/Proof_theory">proof theory</a>, on which type theory and proof assistants are based). Interestingly, in model checking, the dominant paradigm seems to change about once a decade. Overall, its timeline looks something like this:</p>
<ul>
<li><strong>1980s</strong> - The birth of the very idea of MC from the works of <a href="https://en.wikipedia.org/wiki/Edmund_M._Clarke">Edmund Clarke</a> on calculating fixed points for proof systems in <a href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics">predicate transformers</a>; use of <a href="https://en.wikipedia.org/wiki/Binary_decision_diagram">BDD</a> for state compaction</li>
<li><strong>1990s</strong> - Further state reduction through <a href="https://en.wikipedia.org/wiki/Partial_order_reduction">partial order reduction</a>; the emergence of <a href="https://www.cs.unc.edu/~stotts/COMP590-059-f21/slides/mcheck-survey.%20pdf#page=20">predicate abstraction</a> and <a href="https://web.stanford.edu/class/cs357/cegar.pdf">CEGAR</a> - methods for automatically constructing models from a set of assertions about a program</li>
<li>2000s - SAT/SMT revolution (https://www.cs.rice.edu/~vardi/papers/highlights15.pdf) and departure from BDD; fast approximation through <a href="https://clayrat.github.io/posts/2023-07-24-interpolation-ssr.html">Craig interpolation</a></li>
<li>2010s - Aaron Bradley invents the <a href="https://arieg.bitbucket.io/pdf/gurfinkel_ssft15.pdf">PDR</a> family of algorithms, where the process of constructing an invariant alternates and interacts with the construction of a counterexample, mutually intersecting the corresponding search spaces</li>
<li>2020s - Excitement around machine learning techniques</li>
</ul>
<p>The first three decades and their main ideas are described in the first two and a half chapters of the dissertation (the second half of the third and fourth chapters are more technical).</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
